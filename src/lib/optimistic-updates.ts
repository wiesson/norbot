import type { OptimisticLocalStore } from "convex/browser";
import { api } from "@convex/_generated/api";
import type { Id } from "@convex/_generated/dataModel";
import type { KanbanTask, KanbanData, KanbanArgs, TaskStatus } from "./types";

/**
 * Optimistically update a task's status in the kanban board.
 * This moves the task from one column to another immediately in the UI.
 */
export function optimisticStatusUpdate(
  localStore: OptimisticLocalStore,
  kanbanArgs: KanbanArgs,
  taskId: Id<"tasks">,
  newStatus: TaskStatus
) {
  const currentValue = localStore.getQuery(api.tasks.getKanban, kanbanArgs);
  if (currentValue === undefined) return;

  const kanbanData = currentValue as KanbanData;

  // Find the task in any column
  let task: KanbanTask | undefined;
  let oldStatus: keyof KanbanData["columns"] | undefined;

  for (const [status, tasks] of Object.entries(kanbanData.columns)) {
    const found = tasks.find((t: KanbanTask) => t._id === taskId);
    if (found) {
      task = found;
      oldStatus = status as keyof KanbanData["columns"];
      break;
    }
  }

  if (!task || !oldStatus) return;

  // Don't do anything if status hasn't changed
  if (oldStatus === newStatus) return;

  // Create new columns with the task moved
  const newColumns = { ...kanbanData.columns };

  // Remove from old column
  newColumns[oldStatus] = kanbanData.columns[oldStatus].filter(
    (t: KanbanTask) => t._id !== taskId
  );

  // Add to new column (at the end)
  const newStatusKey = newStatus as keyof KanbanData["columns"];
  newColumns[newStatusKey] = [
    ...kanbanData.columns[newStatusKey],
    { ...task, status: newStatus },
  ];

  // Using type assertion since optimistic updates operate on partial data
  // The actual query will refresh with full data from the server
  localStore.setQuery(api.tasks.getKanban, kanbanArgs, {
    ...kanbanData,
    columns: newColumns,
  } as typeof currentValue);
}

/**
 * Optimistically add a new task to the kanban board.
 * The task is added to the specified status column (defaults to backlog).
 */
export function optimisticTaskCreate(
  localStore: OptimisticLocalStore,
  kanbanArgs: KanbanArgs,
  taskData: {
    title: string;
    description?: string;
    priority: "critical" | "high" | "medium" | "low";
    taskType: "bug" | "feature" | "improvement" | "task" | "question";
    status?: "backlog" | "todo" | "in_progress" | "in_review";
    labels?: string[];
    projectShortCode?: string;
  }
) {
  const currentValue = localStore.getQuery(api.tasks.getKanban, kanbanArgs);
  if (currentValue === undefined) return;

  const kanbanData = currentValue as KanbanData;
  const status = taskData.status ?? "backlog";

  // Create a temporary task with a placeholder ID
  // The real ID will be assigned by the server
  const tempTask: KanbanTask = {
    _id: `temp_${Date.now()}` as Id<"tasks">,
    displayId: "...", // Will be generated by server
    title: taskData.title,
    description: taskData.description,
    priority: taskData.priority,
    taskType: taskData.taskType,
    status,
    labels: taskData.labels ?? [],
    projectShortCode: taskData.projectShortCode,
    source: { type: "manual" },
    _isOptimistic: true, // Flag for optimistic state detection
  };

  // Add to the appropriate column
  const newColumns = { ...kanbanData.columns };
  newColumns[status] = [...kanbanData.columns[status], tempTask];

  // Update stats
  const newStats = {
    ...kanbanData.stats,
    total: kanbanData.stats.total + 1,
    byPriority: {
      ...kanbanData.stats.byPriority,
      [taskData.priority]: kanbanData.stats.byPriority[taskData.priority] + 1,
    },
  };

  // Using type assertion since optimistic updates operate on partial data
  // The actual query will refresh with full data from the server
  localStore.setQuery(api.tasks.getKanban, kanbanArgs, {
    columns: newColumns,
    stats: newStats,
  } as typeof currentValue);
}
